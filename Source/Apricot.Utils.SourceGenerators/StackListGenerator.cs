using System.Globalization;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Apricot.Utils.SourceGenerators;

[Generator]
public sealed class StackListGenerator : IIncrementalGenerator
{
    private static readonly int[] DefaultCapacities = [4, 8, 16, 32, 64];

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var capacitiesProvider = context.AnalyzerConfigOptionsProvider
            .Select((opts, _) =>
                opts.GlobalOptions.TryGetValue("build_property.StackListCapacities", out var raw)
                && !string.IsNullOrWhiteSpace(raw)
                    ? ParseIntList(raw)
                    : DefaultCapacities
            );

        context.RegisterSourceOutput(capacitiesProvider, static (spc, capacities) =>
        {
            foreach (var capacity in capacities)
            {
                if (capacity <= 0) continue;
                var name = $"StackList{capacity}";
                var src = GenerateType(capacity);
                spc.AddSource($"{name}.g.cs", SourceText.From(src, System.Text.Encoding.UTF8));
            }
        });
    }

    private static int[] ParseIntList(string raw) => raw
        .Split([',', ';', ' '], StringSplitOptions.RemoveEmptyEntries)
        .Select(s => int.TryParse(s, NumberStyles.Integer, CultureInfo.InvariantCulture, out var v)
            ? (int?)v
            : null
        )
        .Where(v => v.HasValue)
        .Select(v => v!.Value)
        .ToArray();


    private static string GenerateType(int capacity) =>
        $$"""
          // <auto-generated />
          #nullable enable
          using System;
          using System.Collections;
          using System.Collections.Generic;
          using System.Runtime.CompilerServices;
          using System.Runtime.InteropServices;

          namespace Apricot.Utils.Collections
          {
              /// <summary>
              /// StackList{{capacity}} is a simple stack-allocated list (Span-backed via InlineArray).
              /// It does not expand beyond its specified capacity ({{capacity}}).
              /// </summary>
              public struct StackList{{capacity}}<T> : IEnumerable<T>, IList<T>
              {
                  public const int TypeCapacity = {{capacity}};

                  [InlineArray(TypeCapacity)]
                  private struct Elements { private T _element0; }

                  private Elements elements;
                  private int count;

                  public readonly int Count => count;
                  public readonly int Capacity => TypeCapacity;
                  public readonly bool IsReadOnly => false;

                  /// <summary>Writable span over the active elements [0..Count).</summary>
                  public Span<T> Span => MemoryMarshal.CreateSpan(ref elements[0], Count);

                  /// <summary>Read-only span over the active elements [0..Count).</summary>
                  public ReadOnlySpan<T> ReadOnlySpan => MemoryMarshal.CreateReadOnlySpan(ref elements[0], Count);
                  
                  public StackList{{capacity}}(in ReadOnlySpan<T> initialElements) 
                  {
                      if (initialElements.Length > Capacity) 
                      {
                          throw new InvalidOperationException("Exceeding Capacity of StackList{{capacity}}");
                      }
                      
                      initialElements.CopyTo(elements);
                  }

                  public void Add(T value)
                  {
                      if (count >= Capacity)
                          throw new Exception("Exceeding Capacity of StackList{{capacity}}");
                      elements[count++] = value;
                  }

                  public void Resize(int newCount)
                  {
                      if (newCount < 0 || newCount > Capacity)
                          throw new Exception("Exceeding Capacity of StackList{{capacity}}");
                      // If growing, new slots remain default(T)
                      if (newCount < count)
                      {
                          // clear tail to keep GC happy for ref T
                          for (int i = newCount; i < count; i++) elements[i] = default!;
                      }
                      count = newCount;
                  }

                  public void RemoveAt(int index)
                  {
                      if ((uint)index >= (uint)count)
                          throw new IndexOutOfRangeException();
                      for (int i = index; i < count - 1; i++)
                          elements[i] = elements[i + 1];
                      elements[--count] = default!;
                  }

                  public void Clear()
                  {
                      for (int i = 0; i < count; i++)
                          elements[i] = default!;
                      count = 0;
                  }

                  public readonly int IndexOf(T item)
                  {
                      var cmp = EqualityComparer<T>.Default;
                      for (int i = 0; i < count; i++)
                          if (cmp.Equals(elements[i], item))
                              return i;
                      return -1;
                  }

                  public void Insert(int index, T item)
                  {
                      if ((uint)index > (uint)count)
                          throw new IndexOutOfRangeException();
                      if (count >= Capacity)
                          throw new InvalidOperationException("Exceeding Capacity of StackList{{capacity}}");
                      for (int i = count; i > index; i--)
                          elements[i] = elements[i - 1];
                      elements[index] = item;
                      count++;
                  }

                  public readonly bool Contains(T item) => IndexOf(item) >= 0;

                  public readonly void CopyTo(T[] array, int arrayIndex)
                  {
                      if (array is null) throw new ArgumentNullException(nameof(array));
                      if (arrayIndex < 0) throw new ArgumentOutOfRangeException(nameof(arrayIndex));
                      if (array.Length - arrayIndex < count) throw new ArgumentException("Destination too short");
                      for (int i = 0; i < count; i++)
                          array[arrayIndex + i] = elements[i];
                  }

                  public bool Remove(T item)
                  {
                      var idx = IndexOf(item);
                      if (idx < 0) return false;
                      RemoveAt(idx);
                      return true;
                  }

                  public T this[int index]
                  {
                      readonly get
                      {
                          if ((uint)index >= (uint)count)
                              throw new IndexOutOfRangeException();
                          return elements[index];
                      }
                      set
                      {
                          if ((uint)index >= (uint)count)
                              throw new IndexOutOfRangeException();
                          elements[index] = value;
                      }
                  }

                  public readonly Enumerator GetEnumerator() => new(this);

                  readonly IEnumerator<T> IEnumerable<T>.GetEnumerator() => new Enumerator(this);
                  readonly IEnumerator IEnumerable.GetEnumerator() => new Enumerator(this);

                  public struct Enumerator(in StackList{{capacity}}<T> list) : IEnumerator<T>
                  {
                      private StackList{{capacity}}<T> list = list;
                      private int index = -1;

                      public readonly T Current => list[index];
                      readonly object IEnumerator.Current => Current!;

                      public readonly void Dispose() { }
                      public bool MoveNext() => (++index) < list.Count;
                      public void Reset() => index = -1;
                  }
              }
          }

          """;
}
